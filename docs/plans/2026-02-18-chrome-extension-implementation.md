# Polovni Automobili Comments Extension â€” Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build a Chrome extension that injects a real-time community comment drawer into car listing pages on polovniautomobili.com, backed by Convex.

**Architecture:** A Manifest V3 content script detects listing pages, creates a Shadow DOM host, and mounts a React app inside it (style-isolated from the host page). Convex stores comments and votes; the extension communicates with it directly using the Convex React client. Anonymous user identity is a UUID persisted in `chrome.storage.local`.

**Tech Stack:** React 18, TypeScript, Tailwind CSS, Vite + CRXJS, Convex, Vitest + convex-test

---

## Project Structure

```
polovni-comments/
â”œâ”€â”€ manifest.json
â”œâ”€â”€ vite.config.ts
â”œâ”€â”€ tailwind.config.ts
â”œâ”€â”€ tsconfig.json
â”œâ”€â”€ .env                          # VITE_CONVEX_URL=...
â”œâ”€â”€ package.json
â”œâ”€â”€ convex/
â”‚   â”œâ”€â”€ schema.ts
â”‚   â”œâ”€â”€ comments.ts
â”‚   â”œâ”€â”€ votes.ts
â”‚   â””â”€â”€ _generated/               # auto-generated by Convex CLI
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ content/
â”‚   â”‚   â”œâ”€â”€ index.tsx             # Shadow DOM mount + React entry
â”‚   â”‚   â””â”€â”€ shadow.css            # Tailwind directives
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ App.tsx               # ConvexProvider wrapper
â”‚   â”‚   â”œâ”€â”€ Drawer.tsx            # Fixed right drawer + toggle tab
â”‚   â”‚   â”œâ”€â”€ CommentList.tsx       # Scrollable list of comments
â”‚   â”‚   â”œâ”€â”€ CommentItem.tsx       # Single comment + vote buttons
â”‚   â”‚   â””â”€â”€ PostForm.tsx          # Textarea + submit
â”‚   â””â”€â”€ utils/
â”‚       â”œâ”€â”€ listingId.ts          # Extract ID from URL
â”‚       â””â”€â”€ anonymousId.ts        # Generate/persist UUID
â””â”€â”€ docs/plans/
```

---

## Task 1: Project Scaffold

**Files:**
- Create: `package.json`
- Create: `manifest.json`
- Create: `vite.config.ts`
- Create: `tailwind.config.ts`
- Create: `tsconfig.json`
- Create: `.env`
- Create: `src/content/shadow.css`

**Step 1: Install dependencies**

```bash
cd /Users/djordje/projects/polovni-comments
npm create vite@latest . -- --template react-ts
npm install convex
npm install -D @crxjs/vite-plugin tailwindcss @tailwindcss/vite vitest convex-test
npm install -D @types/chrome
```

**Step 2: Write `manifest.json`**

```json
{
  "manifest_version": 3,
  "name": "Polovni Automobili Comments",
  "version": "1.0.0",
  "description": "Community comments on car listings",
  "permissions": ["storage"],
  "content_scripts": [
    {
      "matches": ["https://www.polovniautomobili.com/auto-oglasi/oglas/*"],
      "js": ["src/content/index.tsx"]
    }
  ]
}
```

**Step 3: Write `vite.config.ts`**

```typescript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import { crx } from '@crxjs/vite-plugin'
import tailwindcss from '@tailwindcss/vite'
import manifest from './manifest.json'

export default defineConfig({
  plugins: [
    react(),
    tailwindcss(),
    crx({ manifest }),
  ],
  test: {
    environment: 'edge-runtime',
    server: { deps: { inline: ['convex-test'] } },
  },
})
```

**Step 4: Write `tailwind.config.ts`**

```typescript
import type { Config } from 'tailwindcss'

export default {
  content: ['./src/**/*.{ts,tsx}'],
} satisfies Config
```

**Step 5: Write `tsconfig.json`**

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "lib": ["ES2020", "DOM"],
    "module": "ESNext",
    "moduleResolution": "bundler",
    "jsx": "react-jsx",
    "strict": true,
    "types": ["chrome", "vite/client"]
  },
  "include": ["src", "convex"]
}
```

**Step 6: Write `src/content/shadow.css`**

```css
@import "tailwindcss";
```

**Step 7: Write `.env`**

```
VITE_CONVEX_URL=https://PLACEHOLDER.convex.cloud
```

(Will be replaced after Convex setup in Task 2.)

**Step 8: Commit**

```bash
git add -A
git commit -m "feat: scaffold project with Vite, CRXJS, React, Tailwind"
```

---

## Task 2: Convex Project Setup

**Files:**
- Create: `convex/schema.ts`

**Step 1: Initialize Convex**

```bash
npx convex dev
```

Follow the prompts: create a new project, log in if needed. This generates `convex/_generated/` and prints your deployment URL.

**Step 2: Update `.env` with your real Convex URL**

Replace the placeholder in `.env`:
```
VITE_CONVEX_URL=https://YOUR-REAL-URL.convex.cloud
```

**Step 3: Write `convex/schema.ts`**

```typescript
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
  comments: defineTable({
    listingId: v.string(),
    authorId: v.string(),
    text: v.string(),
    createdAt: v.number(),
  }).index("by_listing", ["listingId"]),

  votes: defineTable({
    commentId: v.id("comments"),
    voterId: v.string(),
    direction: v.union(v.literal("up"), v.literal("down")),
  })
    .index("by_comment", ["commentId"])
    .index("by_comment_voter", ["commentId", "voterId"]),
});
```

**Step 4: Commit**

```bash
git add convex/schema.ts .env
git commit -m "feat: add Convex schema for comments and votes"
```

---

## Task 3: Convex Query â€” `getComments`

**Files:**
- Create: `convex/comments.ts`
- Create: `convex/comments.test.ts`

**Step 1: Write the failing test**

```typescript
// convex/comments.test.ts
import { convexTest } from "convex-test";
import { expect, test } from "vitest";
import { api } from "./_generated/api";
import schema from "./schema";

test("getComments returns empty array for unknown listing", async () => {
  const t = convexTest(schema);
  const comments = await t.query(api.comments.getComments, {
    listingId: "99999",
  });
  expect(comments).toEqual([]);
});

test("getComments returns comments for listing sorted by score desc", async () => {
  const t = convexTest(schema);

  // Post two comments
  await t.mutation(api.comments.postComment, {
    listingId: "12345",
    text: "First comment",
    authorId: "user-a",
  });
  await t.mutation(api.comments.postComment, {
    listingId: "12345",
    text: "Second comment",
    authorId: "user-b",
  });

  const comments = await t.query(api.comments.getComments, {
    listingId: "12345",
  });
  expect(comments).toHaveLength(2);
  expect(comments[0].text).toBeDefined();
  expect(comments[0].score).toBeDefined();
});
```

**Step 2: Run tests to verify they fail**

```bash
npx vitest run convex/comments.test.ts
```

Expected: FAIL â€” "api.comments.getComments is not a function" (module doesn't exist yet)

**Step 3: Write `convex/comments.ts`**

```typescript
import { v } from "convex/values";
import { query, mutation } from "./_generated/server";

export const getComments = query({
  args: { listingId: v.string() },
  handler: async (ctx, { listingId }) => {
    const comments = await ctx.db
      .query("comments")
      .withIndex("by_listing", (q) => q.eq("listingId", listingId))
      .collect();

    const withScores = await Promise.all(
      comments.map(async (comment) => {
        const votes = await ctx.db
          .query("votes")
          .withIndex("by_comment", (q) => q.eq("commentId", comment._id))
          .collect();
        const score = votes.reduce(
          (acc, v) => acc + (v.direction === "up" ? 1 : -1),
          0
        );
        return { ...comment, score };
      })
    );

    return withScores.sort((a, b) => b.score - a.score);
  },
});

export const postComment = mutation({
  args: {
    listingId: v.string(),
    text: v.string(),
    authorId: v.string(),
  },
  handler: async (ctx, { listingId, text, authorId }) => {
    if (text.trim().length === 0) throw new Error("Comment cannot be empty");
    if (text.length > 1000) throw new Error("Comment too long");

    return ctx.db.insert("comments", {
      listingId,
      authorId,
      text: text.trim(),
      createdAt: Date.now(),
    });
  },
});
```

**Step 4: Run tests to verify they pass**

```bash
npx vitest run convex/comments.test.ts
```

Expected: PASS

**Step 5: Commit**

```bash
git add convex/comments.ts convex/comments.test.ts
git commit -m "feat: add getComments query and postComment mutation"
```

---

## Task 4: Convex Mutation â€” `vote`

**Files:**
- Create: `convex/votes.ts`
- Create: `convex/votes.test.ts`

**Step 1: Write the failing tests**

```typescript
// convex/votes.test.ts
import { convexTest } from "convex-test";
import { expect, test } from "vitest";
import { api } from "./_generated/api";
import schema from "./schema";

async function setupComment(t: ReturnType<typeof convexTest>) {
  const id = await t.mutation(api.comments.postComment, {
    listingId: "12345",
    text: "Test",
    authorId: "author",
  });
  return id;
}

test("vote: creates upvote", async () => {
  const t = convexTest(schema);
  const commentId = await setupComment(t);

  await t.mutation(api.votes.vote, {
    commentId,
    voterId: "user-a",
    direction: "up",
  });

  const comments = await t.query(api.comments.getComments, { listingId: "12345" });
  expect(comments[0].score).toBe(1);
});

test("vote: toggling same direction removes vote", async () => {
  const t = convexTest(schema);
  const commentId = await setupComment(t);

  await t.mutation(api.votes.vote, { commentId, voterId: "user-a", direction: "up" });
  await t.mutation(api.votes.vote, { commentId, voterId: "user-a", direction: "up" });

  const comments = await t.query(api.comments.getComments, { listingId: "12345" });
  expect(comments[0].score).toBe(0);
});

test("vote: switching direction replaces vote", async () => {
  const t = convexTest(schema);
  const commentId = await setupComment(t);

  await t.mutation(api.votes.vote, { commentId, voterId: "user-a", direction: "up" });
  await t.mutation(api.votes.vote, { commentId, voterId: "user-a", direction: "down" });

  const comments = await t.query(api.comments.getComments, { listingId: "12345" });
  expect(comments[0].score).toBe(-1);
});

test("vote: multiple voters accumulate correctly", async () => {
  const t = convexTest(schema);
  const commentId = await setupComment(t);

  await t.mutation(api.votes.vote, { commentId, voterId: "user-a", direction: "up" });
  await t.mutation(api.votes.vote, { commentId, voterId: "user-b", direction: "up" });
  await t.mutation(api.votes.vote, { commentId, voterId: "user-c", direction: "down" });

  const comments = await t.query(api.comments.getComments, { listingId: "12345" });
  expect(comments[0].score).toBe(1); // 2 up - 1 down
});
```

**Step 2: Run tests to verify they fail**

```bash
npx vitest run convex/votes.test.ts
```

Expected: FAIL â€” "api.votes is not defined"

**Step 3: Write `convex/votes.ts`**

```typescript
import { v } from "convex/values";
import { mutation } from "./_generated/server";

export const vote = mutation({
  args: {
    commentId: v.id("comments"),
    voterId: v.string(),
    direction: v.union(v.literal("up"), v.literal("down")),
  },
  handler: async (ctx, { commentId, voterId, direction }) => {
    const existing = await ctx.db
      .query("votes")
      .withIndex("by_comment_voter", (q) =>
        q.eq("commentId", commentId).eq("voterId", voterId)
      )
      .unique();

    if (!existing) {
      // No vote yet â€” create
      await ctx.db.insert("votes", { commentId, voterId, direction });
    } else if (existing.direction === direction) {
      // Same direction â€” toggle off
      await ctx.db.delete(existing._id);
    } else {
      // Different direction â€” switch
      await ctx.db.patch(existing._id, { direction });
    }
  },
});
```

**Step 4: Run tests to verify they pass**

```bash
npx vitest run convex/votes.test.ts
```

Expected: PASS (all 4 tests)

**Step 5: Commit**

```bash
git add convex/votes.ts convex/votes.test.ts
git commit -m "feat: add vote mutation with toggle and switch logic"
```

---

## Task 5: Utility â€” `extractListingId`

**Files:**
- Create: `src/utils/listingId.ts`
- Create: `src/utils/listingId.test.ts`

**Step 1: Write the failing tests**

```typescript
// src/utils/listingId.test.ts
import { expect, test } from "vitest";
import { extractListingId } from "./listingId";

test("extracts ID from standard listing URL", () => {
  expect(
    extractListingId("https://www.polovniautomobili.com/auto-oglasi/oglas/kia-sportage-1-6-crdi-24536789.html")
  ).toBe("24536789");
});

test("extracts ID when car name has many hyphens", () => {
  expect(
    extractListingId("https://www.polovniautomobili.com/auto-oglasi/oglas/mercedes-benz-c-220-d-amg-line-99887766.html")
  ).toBe("99887766");
});

test("returns null for non-listing URL", () => {
  expect(
    extractListingId("https://www.polovniautomobili.com/auto-oglasi/")
  ).toBeNull();
});

test("returns null for empty string", () => {
  expect(extractListingId("")).toBeNull();
});
```

**Step 2: Run tests to verify they fail**

```bash
npx vitest run src/utils/listingId.test.ts
```

Expected: FAIL â€” "extractListingId is not a function"

**Step 3: Write `src/utils/listingId.ts`**

```typescript
/**
 * Extracts the numeric listing ID from a Polovni Automobili listing URL.
 * Pattern: /auto-oglasi/oglas/<slug>-<id>.html
 * Returns null if no ID can be extracted.
 */
export function extractListingId(url: string): string | null {
  const match = /\/auto-oglasi\/oglas\/[^/]+-(\d+)\.html/.exec(url);
  return match ? match[1] : null;
}
```

**Step 4: Run tests to verify they pass**

```bash
npx vitest run src/utils/listingId.test.ts
```

Expected: PASS

**Step 5: Commit**

```bash
git add src/utils/listingId.ts src/utils/listingId.test.ts
git commit -m "feat: add listingId URL extraction utility"
```

---

## Task 6: Utility â€” `anonymousId`

**Files:**
- Create: `src/utils/anonymousId.ts`
- Create: `src/utils/anonymousId.test.ts`

**Step 1: Write the failing tests**

```typescript
// src/utils/anonymousId.test.ts
import { expect, test, vi, beforeEach } from "vitest";
import { getOrCreateAnonymousId } from "./anonymousId";

// Mock chrome.storage.local
const store: Record<string, string> = {};
const chromeMock = {
  storage: {
    local: {
      get: vi.fn(async (key: string) => ({ [key]: store[key] })),
      set: vi.fn(async (obj: Record<string, string>) => {
        Object.assign(store, obj);
      }),
    },
  },
};
vi.stubGlobal("chrome", chromeMock);

beforeEach(() => {
  Object.keys(store).forEach((k) => delete store[k]);
  vi.clearAllMocks();
});

test("generates and stores a UUID on first call", async () => {
  const id = await getOrCreateAnonymousId();
  expect(id).toMatch(
    /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i
  );
  expect(chromeMock.storage.local.set).toHaveBeenCalledWith({ anonymousId: id });
});

test("returns the same ID on subsequent calls", async () => {
  const id1 = await getOrCreateAnonymousId();
  const id2 = await getOrCreateAnonymousId();
  expect(id1).toBe(id2);
});
```

**Step 2: Run tests to verify they fail**

```bash
npx vitest run src/utils/anonymousId.test.ts
```

Expected: FAIL â€” "getOrCreateAnonymousId is not a function"

**Step 3: Write `src/utils/anonymousId.ts`**

```typescript
const STORAGE_KEY = "anonymousId";

export async function getOrCreateAnonymousId(): Promise<string> {
  const result = await chrome.storage.local.get(STORAGE_KEY);
  if (result[STORAGE_KEY]) return result[STORAGE_KEY];

  const id = crypto.randomUUID();
  await chrome.storage.local.set({ [STORAGE_KEY]: id });
  return id;
}
```

**Step 4: Run tests to verify they pass**

```bash
npx vitest run src/utils/anonymousId.test.ts
```

Expected: PASS

**Step 5: Commit**

```bash
git add src/utils/anonymousId.ts src/utils/anonymousId.test.ts
git commit -m "feat: add anonymous ID generation with chrome.storage persistence"
```

---

## Task 7: Content Script â€” Shadow DOM Mount

**Files:**
- Create: `src/content/index.tsx`

**Step 1: Write `src/content/index.tsx`**

```typescript
import React from "react";
import { createRoot } from "react-dom/client";
import { extractListingId } from "../utils/listingId";
import { getOrCreateAnonymousId } from "../utils/anonymousId";
import App from "../components/App";
import styles from "./shadow.css?inline";

async function main() {
  const listingId = extractListingId(window.location.href);
  if (!listingId) return; // Not a listing page

  const anonymousId = await getOrCreateAnonymousId();

  // Create shadow host
  const host = document.createElement("div");
  host.id = "pa-comments-host";
  document.body.appendChild(host);

  // Attach shadow root
  const shadow = host.attachShadow({ mode: "open" });

  // Inject Tailwind styles into shadow root
  const style = document.createElement("style");
  style.textContent = styles;
  shadow.appendChild(style);

  // Mount React app
  const container = document.createElement("div");
  shadow.appendChild(container);

  createRoot(container).render(
    <React.StrictMode>
      <App listingId={listingId} anonymousId={anonymousId} />
    </React.StrictMode>
  );
}

main();
```

**Step 2: Verify it compiles (no test for DOM injection â€” covered by manual smoke test)**

```bash
npx tsc --noEmit
```

Expected: no errors

**Step 3: Commit**

```bash
git add src/content/index.tsx
git commit -m "feat: add content script with Shadow DOM mount"
```

---

## Task 8: `CommentItem` Component

**Files:**
- Create: `src/components/CommentItem.tsx`

**Step 1: Write `src/components/CommentItem.tsx`**

```typescript
import { Id } from "../../convex/_generated/dataModel";

export interface Comment {
  _id: Id<"comments">;
  text: string;
  score: number;
  createdAt: number;
  authorId: string;
}

interface Props {
  comment: Comment;
  currentVote: "up" | "down" | null;
  onVote: (direction: "up" | "down") => void;
}

export function CommentItem({ comment, currentVote, onVote }: Props) {
  const timeAgo = formatTimeAgo(comment.createdAt);

  return (
    <div className="flex gap-2 py-3 border-b border-gray-100 last:border-0">
      {/* Vote column */}
      <div className="flex flex-col items-center gap-1 pt-0.5">
        <button
          onClick={() => onVote("up")}
          className={`text-lg leading-none transition-colors ${
            currentVote === "up"
              ? "text-orange-500"
              : "text-gray-400 hover:text-gray-600"
          }`}
          aria-label="Upvote"
        >
          â–²
        </button>
        <span className="text-xs font-semibold text-gray-600 tabular-nums">
          {comment.score}
        </span>
        <button
          onClick={() => onVote("down")}
          className={`text-lg leading-none transition-colors ${
            currentVote === "down"
              ? "text-blue-500"
              : "text-gray-400 hover:text-gray-600"
          }`}
          aria-label="Downvote"
        >
          â–¼
        </button>
      </div>

      {/* Content column */}
      <div className="flex-1 min-w-0">
        <p className="text-sm text-gray-800 break-words">{comment.text}</p>
        <p className="text-xs text-gray-400 mt-1">{timeAgo}</p>
      </div>
    </div>
  );
}

function formatTimeAgo(timestamp: number): string {
  const diff = Date.now() - timestamp;
  const minutes = Math.floor(diff / 60_000);
  if (minutes < 1) return "just now";
  if (minutes < 60) return `${minutes}m ago`;
  const hours = Math.floor(minutes / 60);
  if (hours < 24) return `${hours}h ago`;
  const days = Math.floor(hours / 24);
  if (days < 7) return `${days}d ago`;
  const weeks = Math.floor(days / 7);
  return `${weeks}w ago`;
}
```

**Step 2: Commit**

```bash
git add src/components/CommentItem.tsx
git commit -m "feat: add CommentItem component with vote buttons"
```

---

## Task 9: `PostForm` Component

**Files:**
- Create: `src/components/PostForm.tsx`

**Step 1: Write `src/components/PostForm.tsx`**

```typescript
import { useState } from "react";

interface Props {
  onPost: (text: string) => Promise<void>;
}

export function PostForm({ onPost }: Props) {
  const [text, setText] = useState("");
  const [error, setError] = useState<string | null>(null);
  const [posting, setPosting] = useState(false);

  async function handleSubmit(e: React.FormEvent) {
    e.preventDefault();
    if (!text.trim()) return;
    setPosting(true);
    setError(null);
    try {
      await onPost(text);
      setText("");
    } catch {
      setError("Failed to post. Please try again.");
    } finally {
      setPosting(false);
    }
  }

  return (
    <form onSubmit={handleSubmit} className="p-3 border-b border-gray-200">
      <textarea
        value={text}
        onChange={(e) => setText(e.target.value)}
        placeholder="Leave a comment..."
        maxLength={1000}
        rows={3}
        className="w-full text-sm border border-gray-300 rounded-md p-2 resize-none focus:outline-none focus:ring-2 focus:ring-orange-400"
        disabled={posting}
      />
      {error && <p className="text-xs text-red-500 mt-1">{error}</p>}
      <div className="flex justify-between items-center mt-2">
        <span className="text-xs text-gray-400">{text.length}/1000</span>
        <button
          type="submit"
          disabled={!text.trim() || posting}
          className="text-sm bg-orange-500 text-white px-3 py-1 rounded-md hover:bg-orange-600 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
        >
          {posting ? "Postingâ€¦" : "Post"}
        </button>
      </div>
    </form>
  );
}
```

**Step 2: Commit**

```bash
git add src/components/PostForm.tsx
git commit -m "feat: add PostForm component with optimistic submit"
```

---

## Task 10: `Drawer` Component

**Files:**
- Create: `src/components/Drawer.tsx`

**Step 1: Write `src/components/Drawer.tsx`**

```typescript
import { useState, useEffect } from "react";
import { Comment, CommentItem } from "./CommentItem";
import { PostForm } from "./PostForm";

interface Props {
  comments: Comment[];
  commentCount: number;
  currentVotes: Record<string, "up" | "down">;
  onVote: (commentId: string, direction: "up" | "down") => void;
  onPost: (text: string) => Promise<void>;
  error: string | null;
  onRetry: () => void;
}

const DRAWER_STATE_KEY = "paCommentsDrawerOpen";

export function Drawer({
  comments,
  commentCount,
  currentVotes,
  onVote,
  onPost,
  error,
  onRetry,
}: Props) {
  const [open, setOpen] = useState(false);

  // Restore drawer state from chrome.storage
  useEffect(() => {
    chrome.storage.local.get(DRAWER_STATE_KEY).then((result) => {
      if (result[DRAWER_STATE_KEY] === true) setOpen(true);
    });
  }, []);

  function toggle() {
    const next = !open;
    setOpen(next);
    chrome.storage.local.set({ [DRAWER_STATE_KEY]: next });
  }

  return (
    <>
      {/* Toggle tab â€” always visible */}
      <button
        onClick={toggle}
        className="fixed right-0 top-1/2 -translate-y-1/2 z-[999999] flex flex-col items-center justify-center gap-1 bg-orange-500 text-white w-9 rounded-l-lg py-3 shadow-lg hover:bg-orange-600 transition-colors"
        aria-label="Toggle comments"
      >
        <span className="text-base leading-none">ðŸ’¬</span>
        {commentCount > 0 && (
          <span className="text-[10px] font-bold leading-none">
            {commentCount > 99 ? "99+" : commentCount}
          </span>
        )}
      </button>

      {/* Drawer panel */}
      <div
        className={`fixed top-[80px] right-0 bottom-0 w-[380px] z-[999998] bg-white shadow-2xl flex flex-col transition-transform duration-300 ease-in-out ${
          open ? "translate-x-0" : "translate-x-full"
        }`}
      >
        {/* Header */}
        <div className="flex items-center justify-between px-4 py-3 border-b border-gray-200 shrink-0">
          <h2 className="text-sm font-semibold text-gray-800">
            Community Comments{" "}
            {commentCount > 0 && (
              <span className="text-gray-400">({commentCount})</span>
            )}
          </h2>
          <button
            onClick={toggle}
            className="text-gray-400 hover:text-gray-600 text-lg leading-none"
            aria-label="Close"
          >
            Ã—
          </button>
        </div>

        {/* Post form */}
        <div className="shrink-0">
          <PostForm onPost={onPost} />
        </div>

        {/* Comment list */}
        <div className="flex-1 overflow-y-auto px-3">
          {error ? (
            <div className="flex flex-col items-center gap-2 py-8 text-center">
              <p className="text-sm text-gray-500">{error}</p>
              <button
                onClick={onRetry}
                className="text-sm text-orange-500 hover:underline"
              >
                Retry
              </button>
            </div>
          ) : comments.length === 0 ? (
            <p className="text-sm text-gray-400 text-center py-8">
              No comments yet. Be the first!
            </p>
          ) : (
            comments.map((c) => (
              <CommentItem
                key={c._id}
                comment={c}
                currentVote={currentVotes[c._id] ?? null}
                onVote={(dir) => onVote(c._id, dir)}
              />
            ))
          )}
        </div>
      </div>
    </>
  );
}
```

**Step 2: Commit**

```bash
git add src/components/Drawer.tsx
git commit -m "feat: add Drawer component with fixed position and toggle tab"
```

---

## Task 11: `App` Component â€” Wire Everything Together

**Files:**
- Create: `src/components/App.tsx`

**Step 1: Write `src/components/App.tsx`**

```typescript
import { ConvexProvider, ConvexReactClient, useQuery, useMutation } from "convex/react";
import { useCallback, useMemo, useState } from "react";
import { api } from "../../convex/_generated/api";
import { Id } from "../../convex/_generated/dataModel";
import { Drawer } from "./Drawer";
import { Comment } from "./CommentItem";

const convex = new ConvexReactClient(import.meta.env.VITE_CONVEX_URL as string);

interface AppProps {
  listingId: string;
  anonymousId: string;
}

function CommentApp({ listingId, anonymousId }: AppProps) {
  const commentsRaw = useQuery(api.comments.getComments, { listingId });
  const voteMutation = useMutation(api.votes.vote);
  const postMutation = useMutation(api.comments.postComment);
  const [error, setError] = useState<string | null>(null);
  const [retryKey, setRetryKey] = useState(0);

  // Track current user's votes: commentId -> direction
  const currentVotes = useMemo<Record<string, "up" | "down">>(() => {
    if (!commentsRaw) return {};
    // We'd need to query votes separately to know user's votes.
    // For MVP, optimistically track in local state.
    return {};
  }, [commentsRaw]);

  // Local vote state for immediate feedback
  const [localVotes, setLocalVotes] = useState<Record<string, "up" | "down" | null>>({});

  const comments: Comment[] = (commentsRaw ?? []) as Comment[];

  const handleVote = useCallback(
    async (commentId: string, direction: "up" | "down") => {
      const prev = localVotes[commentId] ?? null;
      const next = prev === direction ? null : direction;
      setLocalVotes((v) => ({ ...v, [commentId]: next }));
      try {
        await voteMutation({
          commentId: commentId as Id<"comments">,
          voterId: anonymousId,
          direction,
        });
      } catch {
        // Revert on failure
        setLocalVotes((v) => ({ ...v, [commentId]: prev }));
      }
    },
    [localVotes, voteMutation, anonymousId]
  );

  const handlePost = useCallback(
    async (text: string) => {
      await postMutation({ listingId, text, authorId: anonymousId });
    },
    [postMutation, listingId, anonymousId]
  );

  const mergedVotes = { ...currentVotes, ...Object.fromEntries(
    Object.entries(localVotes).filter(([, v]) => v !== null) as [string, "up" | "down"][]
  )};

  return (
    <Drawer
      comments={comments}
      commentCount={comments.length}
      currentVotes={mergedVotes}
      onVote={handleVote}
      onPost={handlePost}
      error={commentsRaw === undefined && error ? error : null}
      onRetry={() => setRetryKey((k) => k + 1)}
    />
  );
}

export default function App(props: AppProps) {
  return (
    <ConvexProvider client={convex}>
      <CommentApp {...props} />
    </ConvexProvider>
  );
}
```

**Step 2: Type-check**

```bash
npx tsc --noEmit
```

Expected: no errors

**Step 3: Commit**

```bash
git add src/components/App.tsx
git commit -m "feat: wire App with Convex queries, mutations, and local vote state"
```

---

## Task 12: Build and Smoke Test

**Step 1: Run the Convex dev server** (in one terminal)

```bash
npx convex dev
```

Leave this running.

**Step 2: Build the extension** (in another terminal)

```bash
npm run build
```

Expected: `dist/` folder created with no errors.

**Step 3: Load in Chrome**

1. Open `chrome://extensions`
2. Enable "Developer mode" (top right toggle)
3. Click "Load unpacked"
4. Select the `dist/` folder

**Step 4: Smoke test**

1. Navigate to any car listing, e.g. `https://www.polovniautomobili.com/auto-oglasi/oglas/kia-sportage-XXXXXXXX.html`
2. Verify the orange toggle tab appears on the right edge
3. Click it â€” drawer slides in
4. Post a comment â€” verify it appears
5. Upvote a comment â€” verify score changes
6. Upvote again â€” verify it toggles off
7. Reload the page â€” drawer should reopen (state persisted), comment still there
8. Open the same listing in another Chrome window â€” verify the comment is visible (shared)

**Step 5: Commit**

```bash
git add -A
git commit -m "feat: complete Polovni Automobili Comments extension MVP"
```

---

## Run All Tests

```bash
npx vitest run
```

Expected: all tests pass (Convex function tests + utility tests)
