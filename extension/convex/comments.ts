import { v } from "convex/values";
import { query, mutation } from "./_generated/server";

export const getComments = query({
  args: { listingId: v.string() },
  handler: async (ctx, { listingId }) => {
    const comments = await ctx.db
      .query("comments")
      .withIndex("by_listing", (q) => q.eq("listingId", listingId))
      .collect();

    const withScores = await Promise.all(
      comments.map(async (comment) => {
        const votes = await ctx.db
          .query("votes")
          .withIndex("by_comment", (q) => q.eq("commentId", comment._id))
          .collect();
        const score = votes.reduce(
          (acc, v) => acc + (v.direction === "up" ? 1 : -1),
          0
        );
        return { ...comment, score };
      })
    );

    const topLevel = withScores
      .filter((c) => !c.parentId)
      .sort((a, b) => b.score - a.score);

    const repliesByParent = new Map<string, typeof withScores>();
    for (const c of withScores) {
      if (c.parentId) {
        const key = c.parentId;
        if (!repliesByParent.has(key)) repliesByParent.set(key, []);
        repliesByParent.get(key)!.push(c);
      }
    }
    for (const replies of repliesByParent.values()) {
      replies.sort((a, b) => b.score - a.score);
    }

    return topLevel.map((c) => ({
      ...c,
      replies: repliesByParent.get(c._id) ?? [],
    }));
  },
});

export const postComment = mutation({
  args: {
    listingId: v.string(),
    text: v.string(),
    authorId: v.string(),
    parentId: v.optional(v.id("comments")),
    username: v.string(),
    isAutoGenerated: v.boolean(),
  },
  handler: async (ctx, { listingId, text, authorId, parentId, username, isAutoGenerated }) => {
    const trimmed = text.trim();
    if (trimmed.length === 0) throw new Error("Comment cannot be empty");
    if (trimmed.length > 1000) throw new Error("Comment too long");

    if (parentId) {
      const parent = await ctx.db.get(parentId);
      if (!parent) throw new Error("Parent comment not found");
      if (parent.listingId !== listingId)
        throw new Error("Parent belongs to different listing");
      if (parent.parentId) throw new Error("Cannot reply to a reply");
    }

    return ctx.db.insert("comments", {
      listingId,
      authorId,
      text: trimmed,
      createdAt: Date.now(),
      username,
      isAutoGenerated,
      ...(parentId ? { parentId } : {}),
    });
  },
});

export const getLatestComments = query({
  args: {},
  handler: async (ctx) => {
    const comments = await ctx.db
      .query("comments")
      .withIndex("by_createdAt")
      .order("desc")
      .filter((q) => q.eq(q.field("parentId"), undefined))
      .take(50);

    const withListings = await Promise.all(
      comments.map(async (comment) => {
        const listing = await ctx.db
          .query("listings")
          .withIndex("by_listingId", (q) =>
            q.eq("listingId", comment.listingId)
          )
          .first();

        return {
          _id: comment._id,
          text: comment.text,
          username: comment.username,
          isAutoGenerated: comment.isAutoGenerated,
          createdAt: comment.createdAt,
          listing: listing
            ? {
                title: listing.title,
                price: listing.price,
                imageUrl: listing.imageUrl,
                url: listing.url,
              }
            : null,
        };
      })
    );

    return withListings;
  },
});
