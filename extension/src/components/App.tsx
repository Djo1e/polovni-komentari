import { ConvexProvider, ConvexReactClient, useQuery, useMutation } from "convex/react";
import { useCallback, useState } from "react";
import { api } from "../../convex/_generated/api";
import { Id } from "../../convex/_generated/dataModel";
import { Drawer } from "./Drawer";
import { Comment } from "./CommentItem";
import { ShadowPortalContext } from "../context/shadow-portal";
import { saveUsername } from "../utils/username";
import { ListingInfo } from "../utils/listingInfo";

const convex = new ConvexReactClient(import.meta.env.VITE_CONVEX_URL as string);

interface AppProps {
  listingId: string | null;
  anonymousId: string;
  portalContainer: HTMLElement;
  initialUsername: string;
  initialIsAutoGenerated: boolean;
  listingInfo: ListingInfo | null;
}

function countAllComments(comments: Comment[]): number {
  return comments.reduce((sum, c) => sum + 1 + (c.replies?.length ?? 0), 0);
}

function CommentApp({ listingId, anonymousId, initialUsername, initialIsAutoGenerated, listingInfo }: Omit<AppProps, "portalContainer">) {
  const commentsRaw = useQuery(
    api.comments.getComments,
    listingId ? { listingId } : "skip"
  );
  const latestComments = useQuery(api.comments.getLatestComments);
  const voteMutation = useMutation(api.votes.vote);
  const postMutation = useMutation(api.comments.postComment);
  const upsertListingMutation = useMutation(api.listings.upsertListing);
  const [error, setError] = useState<string | null>(null);
  const [localVotes, setLocalVotes] = useState<Record<string, "up" | "down" | null>>({});
  const [username, setUsername] = useState(initialUsername);
  const [isAutoGenerated, setIsAutoGenerated] = useState(initialIsAutoGenerated);

  const comments: Comment[] = (commentsRaw ?? []) as Comment[];

  const handleUsernameChange = useCallback((newUsername: string, autoGenerated: boolean) => {
    if (autoGenerated) {
      setIsAutoGenerated(true);
      saveUsername(username, true);
    } else {
      setUsername(newUsername);
      setIsAutoGenerated(false);
      saveUsername(newUsername, false);
    }
  }, [username]);

  const handleVote = useCallback(
    async (commentId: string, direction: "up" | "down") => {
      const prev = localVotes[commentId] ?? null;
      const next = prev === direction ? null : direction;
      setLocalVotes((v) => ({ ...v, [commentId]: next }));
      try {
        await voteMutation({
          commentId: commentId as Id<"comments">,
          voterId: anonymousId,
          direction,
        });
      } catch {
        setLocalVotes((v) => ({ ...v, [commentId]: prev }));
      }
    },
    [localVotes, voteMutation, anonymousId]
  );

  const handlePost = useCallback(
    async (text: string) => {
      if (!listingId) return;
      if (listingInfo) {
        await upsertListingMutation({
          listingId,
          ...listingInfo,
        });
      }
      await postMutation({ listingId, text, authorId: anonymousId, username, isAutoGenerated });
    },
    [postMutation, upsertListingMutation, listingId, listingInfo, anonymousId, username, isAutoGenerated]
  );

  const handleReply = useCallback(
    async (parentId: string, text: string) => {
      if (!listingId) return;
      if (listingInfo) {
        await upsertListingMutation({
          listingId,
          ...listingInfo,
        });
      }
      await postMutation({
        listingId,
        text,
        authorId: anonymousId,
        parentId: parentId as Id<"comments">,
        username,
        isAutoGenerated,
      });
    },
    [postMutation, upsertListingMutation, listingId, listingInfo, anonymousId, username, isAutoGenerated]
  );

  const mergedVotes = {
    ...Object.fromEntries(
      Object.entries(localVotes).filter(([, v]) => v !== null) as [string, "up" | "down"][]
    ),
  };

  const connectionError = commentsRaw === undefined ? error : null;

  return (
    <Drawer
      listingId={listingId}
      comments={comments}
      commentCount={countAllComments(comments)}
      latestComments={latestComments ?? []}
      currentVotes={mergedVotes}
      onVote={handleVote}
      onPost={handlePost}
      onReply={handleReply}
      error={connectionError}
      onRetry={() => setError(null)}
      anonymousId={anonymousId}
      username={username}
      isAutoGenerated={isAutoGenerated}
      onUsernameChange={handleUsernameChange}
    />
  );
}

export default function App({ portalContainer, ...props }: AppProps) {
  return (
    <ShadowPortalContext.Provider value={portalContainer}>
      <ConvexProvider client={convex}>
        <CommentApp {...props} />
      </ConvexProvider>
    </ShadowPortalContext.Provider>
  );
}
